[
  {
    "objectID": "558 Homework 6.html",
    "href": "558 Homework 6.html",
    "title": "Homework 6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\n\nlapply() applies a single function to every element in a list. The purrr equivalent is map().\n\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = “kendall” when calling lapply())\n\n\nYou would add method = ‘kendall’ as an additional argument in lapply(). It would be lapply(x, Fun = cor, method = ‘kendall’).\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\n\npurrr is more consistent and has additional helper functions.\n\n\nWhat is a side-effect function?\n\n\nA side-effect function does something other than the ‘main’ goal of the function. There is additional action taken by r.\n\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\n\nA custom function has its own temporary environment. Anything created inside the function only lives there."
  },
  {
    "objectID": "558 Homework 6.html#task-1-conceptual-questions",
    "href": "558 Homework 6.html#task-1-conceptual-questions",
    "title": "Homework 6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\n\nlapply() applies a single function to every element in a list. The purrr equivalent is map().\n\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = “kendall” when calling lapply())\n\n\nYou would add method = ‘kendall’ as an additional argument in lapply(). It would be lapply(x, Fun = cor, method = ‘kendall’).\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\n\npurrr is more consistent and has additional helper functions.\n\n\nWhat is a side-effect function?\n\n\nA side-effect function does something other than the ‘main’ goal of the function. There is additional action taken by r.\n\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\n\nA custom function has its own temporary environment. Anything created inside the function only lives there."
  },
  {
    "objectID": "558 Homework 6.html#task-2-writing-r-functions",
    "href": "558 Homework 6.html#task-2-writing-r-functions",
    "title": "Homework 6",
    "section": "Task 2: Writing R Functions",
    "text": "Task 2: Writing R Functions\nBelow, a function was created to calculate the root mean square error (RMSE). The function takes in a vector of observations that must be all be numeric and a vector of predictions that must all be numeric. Those two vectors must also be equal in length (each observation having a corresponding prediction). The function includes an optional argument to handle any missing values in a vector. The function can’t handle missing values by default, so an argument must be provided if a missing value is present.\n\ngetRMSE&lt;-function(obs, pres, ...){\nif(length(obs)!=length(pres)){\n  stop('Different number of responses and predictions.')\n}\nz&lt;- obs - pres\nvn&lt;-z^2\ng&lt;-mean(vn, ...)\nx&lt;-sqrt(g)\nreturn(x)\n}\n\nTesting our function:\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\n\nThings change if a missing value is added to a vector.\n\nresp[1]&lt;-NA\nresp[6]&lt;-NA\n\ngetRMSE(resp, pred)\n\n[1] NA\n\n\nThe function cannot run with the missing value. We must specify that we want missing values removed.\n\ngetRMSE(resp, pred, na.rm=TRUE)\n\n[1] 0.9630109\n\n\nBelow, a function was created to calculate the mean absolute deviation (MAE). The function takes in a vector of observations that must be all be numeric and a vector of predictions that must all be numeric. Those two vectors must also be equal in length (each observation having a corresponding prediction). The function includes an optional argument to handle any missing values in a vector. The function can’t handle missing values by default, so an argument must be provided if a missing value is present.\n\ngetMAE&lt;-function(obs, pres, ...){\n  if(length(obs)!=length(pres)){\n  stop('Different number of responses and predictions.')\n}\nz&lt;- obs - pres\nvn&lt;-abs(z)\ng&lt;-mean(vn, ...)\nreturn(g)\n}\n\nTesting our function:\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\ngetMAE(resp, pred)\n\n[1] 0.8155776\n\n\nThings change if a missing value is added to a vector.\n\nresp[2]&lt;-NA\nresp[7]&lt;-NA\n\ngetRMSE(resp, pred)\n\n[1] NA\n\n\nThe function cannot run with the missing value. We must specify that we want missing values removed.\n\ngetMAE(resp, pred, na.rm=TRUE)\n\n[1] 0.8200423\n\n\nNow we will build a function that can call either of the above functions or both, with both being returned by default.\n\ngetMEAS&lt;-function(obs, pres, RMSE=TRUE, MAE=TRUE, ...) {\n  if (!is.vector(obs)|!is.atomic(obs)|!is.numeric(obs)){\n    stop('The response vector does not meet function requirements.')\n  }\n  if (!is.vector(pres)|!is.atomic(pres)|!is.numeric(pres)){\n    stop('The prediction vector does not meet function requirements.')\n  }\n    if(length(obs)!=length(pres)){\n  stop('Different number of responses and predictions.')\n}\n  if (RMSE==TRUE & MAE==FALSE) {\n    x&lt;-getRMSE(obs, pres, ...)\n    my_list&lt;-list(RMSE=x)\n  }\n  if (RMSE==FALSE & MAE==TRUE){\n    y&lt;-getMAE(obs, pres, ...)\n    my_list&lt;-list(MAE=y)\n  }\n  if (RMSE==TRUE & MAE==TRUE){\n    x&lt;-getRMSE(obs, pres, ...)\n    y&lt;-getMAE(obs, pres, ...)\n    my_list&lt;-list(RMSE=x, MAE=y)\n  }\nreturn(my_list)\n}\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\ngetMEAS(resp, pred)\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\n\nThe function can also call just one of the measurements.\n\ngetMEAS(resp, pred, RMSE=FALSE)\n\n$MAE\n[1] 0.8155776\n\n\nLet’s give our function vectors with missing values.\n\nresp[3]&lt;-NA\nresp[10]&lt;-NA\n\ngetMEAS(resp, pred)\n\n$RMSE\n[1] NA\n\n$MAE\n[1] NA\n\n\nWe can also specify removing missing values for this function.\n\ngetMEAS(resp, pred, na.rm=TRUE)\n\n$RMSE\n[1] 0.9581899\n\n$MAE\n[1] 0.8160831\n\n\nThe function will not work if the inputs are not of the correct type. For example, the function will not work if the prediction values are stored in a data frame, not a vector. I was unable to actually run this example. It correctly produced the error message, but then I was unable to render the website because of the error. I was unable to find my way around it.\n\npred&lt;-data.frame(pred)\n\ngetMEAS(resp, pred, na.rm=TRUE)\n\nError in getMEAS(resp, pred, na.rm = TRUE): The prediction vector does not meet function requirements."
  },
  {
    "objectID": "558 Homework 6.html#task-3-querying-an-api-and-a-tidy-style-function",
    "href": "558 Homework 6.html#task-3-querying-an-api-and-a-tidy-style-function",
    "title": "Homework 6",
    "section": "Task 3: Querying an API and a Tidy-Style Function",
    "text": "Task 3: Querying an API and a Tidy-Style Function\nNow we are going to create a function that queries newsapi.org. Our function gives the user the option to specify a subject they are interested, the start date to search from, and an API key. Then the function will call data from news articles that meet those specifications.\nThe function uses get() to access the API. The function then parses that data for actual article information (‘content’). Then we use pluck() to grab the ‘articles’ element and that is returned as a data frame.\n\nget_NEWS_API&lt;-function(topic, startdate, APIkey){\n  start&lt;-'https://newsapi.org/v2/everything?q='\n  topic_url&lt;-topic\n  continue&lt;-'&from='\n  startdate_url&lt;-startdate\n  continue2&lt;-'&sortBy=popularity&apiKey='\n  APIkey_url&lt;-APIkey\n  try&lt;-paste0(start,topic_url,continue,startdate_url,continue2,APIkey_url)\n  try2&lt;-httr::GET(try)\n  try3&lt;-fromJSON(rawToChar(try2$content))\n  try4&lt;-purrr::pluck(try3,\"articles\")\n  return(try4)\n}\n\nWe’ll use our function to create two objects, one about football and the other about baseball.\n\nfootball&lt;-get_NEWS_API('football','2024-10-14','42b42fbb54a644faa2b984b30dbe20ae')\n\nbaseball&lt;-get_NEWS_API('baseball','2024-10-14','42b42fbb54a644faa2b984b30dbe20ae')\n\nWe’ll summarize the names of the sources from each object. The tables provide counts for each source name.\n\ntable(football$source$name)\n\n\n Al Jazeera English     Android Central            BBC News     Bleacher Report \n                  5                   1                  25                  18 \n   Business Insider                CNET              Dezeen            Die Zeit \n                  1                   5                   1                   1 \n               ESPN           Frandroid            GameSpot        Highsnobiety \n                  5                   1                   1                   2 \n          HYPEBEAST     Itsnicethat.com            Le Monde       Lifehacker.ru \n                  3                   1                   4                   1 \n        Lillian.com        Mental Floss                 NPR        Ritholtz.com \n                  1                   1                   1                   1 \n      Rolling Stone          Sky Sports           Stereogum       tagesschau.de \n                  1                  13                   2                   1 \n                TMZ             Variety Yahoo Entertainment \n                  1                   1                   2 \n\n\n\ntable(baseball$source$name)\n\n\n           [Removed]             ABC News         Adafruit.com \n                  20                    1                    1 \n        Advocate.com             BBC News      Bleacher Report \n                   1                    3                    2 \n  Bleeding Cool News     Business Insider           CBS Sports \n                   2                    2                    9 \n         CinemaBlend     Cosmopolitan.com         Daily Signal \n                   1                    2                    1 \n            Deadline          Eonline.com                 ESPN \n                   1                    2                    5 \n              Forbes           Fox Sports             GameSpot \n                   5                    5                    1 \n   Gofugyourself.com            HYPEBEAST           Just Jared \n                   1                    1                    2 \n     KicksOnFire.com     MLB Trade Rumors      Naturalnews.com \n                   1                    7                    1 \nNewjerseymonitor.com                  NPR            Predge.jp \n                   1                    1                    1 \n    Psychology Today         Quartz India        Rolling Stone \n                   1                    1                    2 \n         Screen Rant      Shutterbean.com   Sincerelyjules.com \n                   1                    1                    1 \n Stylegirlfriend.com       Superpunch.net              The Cut \n                   1                    1                    1 \n        The Escapist       The New Yorker          The Quietus \n                   1                    3                    1 \n              TVLine    Twistedsifter.com          Vanity Fair \n                   1                    2                    1 \n             Vulture \n                   1 \n\n\nNext, we’ll convert publishedAt to a date. Then we’ll sort the data by their published date/time, ascending. Then we’ll use lag() to grab publishedAt from the previous observation and create prev_pub. We can subtract prev_pub from publishedAt to calculate the time in seconds since the last article was published. pub_diff shows that time in seconds.\n\nfootball&lt;-football |&gt;\n  mutate(publishedAt=ymd_hms(publishedAt)) |&gt;\n  arrange(publishedAt) |&gt;\n  mutate(prev_pub=lag(publishedAt), pub_diff = as.numeric(publishedAt - prev_pub))\n\nbaseball&lt;-baseball |&gt;\n  mutate(publishedAt=ymd_hms(publishedAt)) |&gt;\n  arrange(publishedAt) |&gt;\n  mutate(prev_pub=lag(publishedAt), pub_diff = as.numeric(publishedAt - prev_pub))\n\nNow we’ll use our football data frame and summarize the publishedAt and pub_diff variables.\n\nsmall_football&lt;-football |&gt;\n  select(publishedAt, pub_diff)\n\nmap(small_football, \\(x) c(mean(x, na.rm=TRUE), median(x, na.rm=TRUE), sd(x, na.rm=TRUE)))\n\n$publishedAt\n[1] \"2024-10-15 03:38:15 UTC\" \"2024-10-15 05:12:04 UTC\"\n[3] \"1970-01-01 12:55:09 UTC\"\n\n$pub_diff\n[1] 1659.202 1025.000 2322.912"
  }
]